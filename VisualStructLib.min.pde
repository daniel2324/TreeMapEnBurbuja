static final int MIDDLE = CENTER; static final int START = LEFT; static final int END = RIGHT; static final int NONE = -1; static final int MOUSECLICK = 10; static final int MOUSEUP = 11; static final int MOUSEDOWN = 12; static final int KEYPRESSED = 13; class Style { int _fillColor; int _strokeColor; float _strokeWidth; Style() { _fillColor=MAX_INT;_strokeColor=MAX_INT;_strokeWidth=0; } Style(int a,int b,float c) { _fillColor=a; _strokeColor=b; _strokeWidth=c; } Style fillColor(int a) {_fillColor=a; return this;} int fillColor() {return _fillColor;} Style strokeColor(int a) {_strokeColor=a; return this;} int strokeColor() {return _strokeColor;} Style strokeWidth(float a) {_strokeWidth=a; return this;} float strokeWidth() {return _strokeWidth;} void setProp() { if (_fillColor!=MAX_INT) System.stl.fillColor(_fillColor); if (_strokeColor!=MAX_INT) System.stl.strokeColor(_strokeColor); if (_strokeWidth!=0) System.stl.strokeWidth(_strokeWidth); } void draw() { if (System.stl.fillColor()==NONE) noFill(); else if (System.stl.fillColor()!=MAX_INT) { int argb = System.stl.fillColor(); fill((argb>>16)&0xFF,(argb>>8)&0xFF,argb&0xFF); } if (System.stl.strokeColor()==NONE) noStroke(); else if (System.stl.strokeColor()!=MAX_INT) { int argb = System.stl.strokeColor(); stroke((argb>>16)&0xFF,(argb>>8)&0xFF,argb&0xFF); } if (System.stl.strokeWidth()!=0) {} strokeWeight(System.strokeWidth); } } class Transform { final int TRANSLATE = 0; final int SCALE = 1; final int ROTATE = 2; ArrayList trans = new ArrayList(); class Method { int type; float x,y; Method(int t, float a, float b) { type = t; x = a; y = b; } } Transform reset() { trans.clear(); return this; } Transform scalation(float a,float b) { trans.add(new Method(SCALE,a,b)); return this; } Transform translation(float a,float b) { trans.add(new Method(TRANSLATE,a,b)); return this; } Transform rotation(float a) { trans.add(new Method(ROTATE,a,0)); return this; } void draw() { for (int i=0; i<trans.size(); i++) { Method m = (Method)trans.get(i); switch (m.type) { case TRANSLATE: translate(m.x,m.y); break; case SCALE: scale(m.x,m.y); break; case ROTATE: rotate(radians(m.x)); break; } } } float[] apply(float[] pnt) { float[] tmp = new float[2]; tmp[0]=pnt[0]; tmp[1]=pnt[1]; for (int i=trans.size()-1; i>=0; i--) { Method m = (Method)trans.get(i); switch (m.type) { case TRANSLATE: tmp[0] -= m.x; tmp[1] -= m.y; break; case SCALE: tmp[0] /= m.x; tmp[1] /= m.y; break; case ROTATE: float x1 = tmp[0], y1 = tmp[1], v = m.x; tmp[0] = x1 * cos(v) + y1 * sin(v); tmp[1] = - x1 * sin(v) + y1 * cos(v); break; } } return tmp; } } class Font { PFont _font; String _fontFamily; int _fontSize; int _textAnchor; Font() { _fontSize=0; _textAnchor=-1; } Font(int a, int b, String c) { _fontSize=a; _textAnchor=b; _fontFamily=c; } Font font(PFont a) {_font=a; return this;} PFont font() {return _font;} Font fontFamily(String a) {_fontFamily=a; return this;} String fontFamily() {return _fontFamily;} Font fontSize(int a) {_fontSize=a; return this;} int fontSize() {return _fontSize;} Font textAnchor(int a) {_textAnchor=a; return this;} int textAnchor() {return _textAnchor;} void setProp() { if ((_font==null)&&(_fontFamily!=null)) _font = loadFont(_fontFamily); if (_fontSize!=0) System.fnt.fontSize(_fontSize); if (_textAnchor!=-1) System.fnt.textAnchor(_textAnchor); } void draw() { if (System.stl.strokeColor()==NONE) noFill(); else fill(System.stl.strokeColor()); if (System.fnt.font()!=null) textFont(System.fnt.font()); if (System.fnt.fontSize()!=0) textSize(System.fnt.fontSize()); if (System.fnt.textAnchor()!=-1) textAlign(System.fnt.textAnchor(),CENTER); } } static class System { static Style stl; static Font fnt; static Symbol symbol; static float strokeWidth = 1; static ArrayList styles = new ArrayList(); static ArrayList fonts = new ArrayList(); static ArrayList symbols = new ArrayList(); static void reset() {} static void pushStyle(Style s) { s.fillColor(System.stl.fillColor()); s.strokeColor(System.stl.strokeColor()); s.strokeWidth(System.stl.strokeWidth()); styles.add(s); } static void popStyle() { System.stl = (Style)styles.get(styles.size()-1); styles.remove(styles.size()-1); } static void pushFont(Font f) { f.font(System.fnt.font()); f.fontSize(System.fnt.fontSize()); f.textAnchor(System.fnt.textAnchor()); fonts.add(f); } static void popFont() { System.fnt = (Font)fonts.get(fonts.size()-1); fonts.remove(fonts.size()-1); } } class Bounds { float xMin, yMin, xMax, yMax; Bounds(float a, float b, float c, float d) { xMin=a; yMin=b; xMax=c; yMax=d; } Bounds(Bounds a) { xMin=a.xMin; yMin=a.yMin; xMax=a.xMax; yMax=a.yMax; } float w() {return (xMax-xMin);} float h() {return (yMax-yMin);} void include(float x, float y) { if (x<xMin) xMin = x; if (x>xMax) xMax = x; if (y<yMin) yMin = y; if (y>yMax) yMax = y; } void union(Bounds b) { include(b.xMin, b.yMin); include(b.xMax, b.yMax); } Bounds translate(float x, float y) { xMin += x; xMax += x; yMin += y; yMax += y; return this; } boolean contains(float x, float y) { return (xMin<x)&&(x<xMax)&&(yMin<y)&&(y<yMax); } } class Info { } abstract class Graphic { Style _stl; Bounds _bnds; Transform _trnsf; String _id; Info info; HashMap _events; Bounds bounds() {return _bnds;} Graphic id(String a) {_id=a; return this;} String id() {return _id;} void preDraw() { if (System.stl == null) System.stl = new Style(#FFFFFF,#000000,0.5); if (_stl!=null) { System.pushStyle(new Style()); if (_stl.strokeWidth()>0) System.strokeWidth *= _stl.strokeWidth(); _stl.setProp(); } System.stl.draw(); if (_trnsf!=null) { pushMatrix(); _trnsf.draw(); } } void postDraw() { if (_stl!=null) { System.popStyle(); if (_stl.strokeWidth()>0) System.strokeWidth /= _stl.strokeWidth(); } if (_trnsf!=null) popMatrix(); } abstract void draw(); Graphic resetMatrix() { if (_trnsf!=null) _trnsf.reset(); return this; } Graphic scale(float a,float b) { if (_trnsf==null) _trnsf = new Transform(); _trnsf.scalation(a,b); return this; } Graphic translate(float a,float b) { if (_trnsf==null) _trnsf = new Transform(); _trnsf.translation(a,b); return this; } Graphic rotate(float a) { if (_trnsf==null) _trnsf = new Transform(); _trnsf.rotation(a); return this; } Graphic fillColor(int a) { if (_stl==null) _stl = new Style(); _stl.fillColor(a); return this; } Graphic strokeColor(int a) { if (_stl==null) _stl = new Style(); _stl.strokeColor(a); return this; } Graphic strokeWidth(float a) { if (_stl==null) _stl = new Style(); _stl.strokeWidth(a); return this; } Graphic onEvent(int code, Action act) { if (_events==null) _events = new HashMap(); _events.put(code,act); return this; } void runEvent(int type) { if (_events!=null) { Action act = (Action)_events.get(type); if (act!=null) act.run(this); } } abstract void pick(int type,float[] params, Action act); } class Action { void run(Graphic g) {} } class Group extends Graphic { Font _fnt; Symbol _symbol; ArrayList _children; Group() { _children = new ArrayList(); } Group symbol(float[] v) { if (_symbol==null) _symbol = newSymbol(); _symbol.vertices = v; return this; } ArrayList children() { return _children; } Group add(Graphic a) { _children.add(a); return this; } Group empty() {_children.clear(); return this;} Graphic getById(String n) { Graphic c=null; for (int i=0; i<_children.size();i++) { c = ((Graphic)_children.get(i)); if (c.id()!=null && c.id().equals(n)) return c; else if (c instanceof Group) { Graphic x=null; x = ((Group)c).getById(n); if (x!=null) return x; } } return null; } Group fontFamily(String a) { if (_fnt==null) _fnt = new Font(); _fnt.fontFamily(a); return this; } Group fontSize(int a) { if (_fnt==null) _fnt = new Font(); _fnt.fontSize(a); return this; } Group fontAnchor(int a) { if (_fnt==null) _fnt = new Font(); _fnt.textAnchor(a); return this; } void preDraw() { super.preDraw(); if (System.fnt == null) System.fnt = new Font(10,LEFT,null); if (_fnt!=null) { System.pushFont(new Font()); _fnt.setProp(); } System.fnt.draw(); } void postDraw() { if (_fnt!=null) System.popFont(); super.postDraw(); } void draw() { if (System.symbol==null) System.symbol = newSymbol(); Symbol temp=null; if (_symbol!=null) { temp = System.symbol; System.symbol=_symbol; } preDraw(); for (int i=0; i<_children.size(); i++) ((Graphic)_children.get(i)).draw(); if (_symbol!=null) System.symbol = temp; postDraw(); } void pick(int type,float[] coords, Action act) { float[] pnt; if (_trnsf!=null) pnt = _trnsf.apply(coords); else pnt = coords; for (int i=0; i<_children.size();i++) ((Graphic)_children.get(i)).pick(type,pnt,act); } } Group newGroup() { return new Group();} class Path extends Graphic { float[] _p; int _pc=0,_pcmax=10; int _mode = OPEN; Path() {_p = new float[_pcmax];} Path mode(int a) {_mode=a; return this;} Path reset() { _pc=0; return this; } Path moveTo(float a, float b) { if (_pc+1==_pcmax) expand(_pcmax); _p[_pc*2]=a; _p[_pc*2+1]=b; _pc++; return this; } Path lineTo(float a, float b) { if (_pc+1==_pcmax) expand(_pcmax); _p[_pc*2]=a; _p[_pc*2+1]=b; _pc++; return this; } Path hLineTo(float a) { return this; } Path vLineTo(float a) { return this; } Path cubicTo(float x2,float y2,float x3,float y3,float x4,float y4) { float x1 = _p[(_pc-1)*2]; float y1 = _p[(_pc-1)*2+1]; float d1 = distance(x1,y1,x4,y4); int n = int(d1/4)+10; expand(n+1); for (int i=0; i <= n; ++i) { float t = i*1.0/n; float a = (1.0 - t) * (1.0 - t) * (1.0 - t); float b = 3.0 * t * (1.0 - t) * (1.0 - t); float c = 3.0 * t * t * (1.0-t); float d = t * t * t; float x = a * x1 + b * x2 + c * x3 + d * x4; float y = a * y1 + b * y2 + c * y3 + d * y4; _p[(_pc+i)*2] = x; _p[(_pc+i)*2+1] = y; } _pc += n+1; return this; } Path quadTo(float x1,float y1,float x2,float y2,float x3,float y3) { float x0 = _p[(_pc-1)*2]; float y0 = _p[(_pc-1)*2+1]; float d1 = distance(x1,y1,x3,y3); int n = int(d1/4)+10; expand(n+1); float aX = (2.0f * x1); float aY = (2.0f * y1); float bX = (-x0 + x2); float bY = (-y0 + y2); float cX = (2.0f * x0 - 5.0f * x1 + 4 * x2 - x3); float cY = (2.0f * y0 - 5.0f * y1 + 4 * y2 - y3); float dX = (-x0 + 3.0f * x1 - 3.0f * x2 + x3); float dY = (-y0 + 3.0f * y1 - 3.0f * y2 + y3); for (int i=0; i <= n; ++i) { float t = i*1.0/n; float t2 = t * t; float t3 = t2 * t; float x = 0.5f * (aX + bX * t + cX * t2 + dX * t3); float y = 0.5f * (aY + bY * t + cY * t2 + dY * t3); _p[(_pc+i)*2] = x; _p[(_pc+i)*2+1] = y; } _pc += n+1; return this; } Path arcTo(float cx,float cy,float w,float h,float start,float end) { int n = 90; expand(n); int parts = n; float part = 2.0f * 3.1415926f / parts; int t=0; for (float theta = start; theta < end; theta+=part, t++) { double x = w / 2 * Math.cos(theta); double y = h / 2 * Math.sin(theta); _p[(_pc+t)*2] = (float)(x + cx); _p[(_pc+t)*2+1] = (float)(y + cy); } _pc += t; return this; } Path close() { return this; } float distance(float a,float b,float c,float d) { return sqrt((c-a)*(c-a)+(d-b)*(d-b)); } void expand(int n) { _pcmax += n; float[] t = new float[_pcmax*2]; for (int i=0; i<_pc*2; i++) t[i] = _p[i]; _p = t; } void rebounds() { for (int i=0; i<_pc; i++) { if (_bnds==null) _bnds = new Bounds(_p[i*2], _p[i*2+1], _p[i*2], _p[i*2+1]); else _bnds.include(_p[i*2], _p[i*2+1]); } } void update() { rebounds(); } void draw() { preDraw(); beginShape(); for (int i=0; i<_pc; i++) vertex(_p[i*2], _p[i*2+1]); endShape(_mode); postDraw(); } void pick(int type,float[] pnt, Action act) { if (_mode==CLOSE && pointInPolygon(pnt[0],pnt[1])) { if (act!=null) act.run(this); runEvent(type); } else if (_mode==OPEN && distancePointPolyline(pnt[0],pnt[1])<5) { if (act!=null) act.run(this); runEvent(type); } } boolean pointInBounds(float x, float y, Bounds b) { return (b.xMin<x)&&(x<b.xMax)&&(b.yMin<y)&&(y<b.yMax); } boolean pointInPolygon(float x, float y) { int i, j; boolean c = false; int n = _pc; if (!(pointInBounds(x,y,_bnds))) return false; for (i = 0, j = n - 1; i < n; j = i++) { if ( ( (_p[i*2+1] > y ) != (_p[j*2+1] > y) ) && (x < (_p[j*2] - _p[i*2]) * (y - _p[i*2+1]) / (_p[j*2+1] - _p[i*2+1]) + _p[i*2]) ) c = !c; } return c; } double distancePointSegment(float x,float y,float x1,float y1,float x2,float y2) { float A = x - x1; float B = y - y1; float C = x2 - x1; float D = y2 - y1; float dot = A * C + B * D; float len_sq = C * C + D * D; float param = -1; if (len_sq != 0) param = dot / len_sq; float xx, yy; if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; } float dx = x - xx; float dy = y - yy; return Math.sqrt(dx * dx + dy * dy); } double distancePointPolyline(float x, float y) { int n = _pc; float distance = MAX_FLOAT; float temp; for (int i=0; i<n-1; i++) { temp = (float)distancePointSegment(x, y, _p[i*2], _p[i*2+1], _p[i*2+2], _p[i*2+3]); if (distance > temp) distance = temp; } return distance; } } Path newPath() { return new Path();} class Location extends Path { float _x, _y; Location x(float a) {_x=a; update(); return this;} Location y(float a) {_y=a; update(); return this;} float x() {return _x;} float y() {return _y;} } class Rect extends Location { float _w, _h; Rect(float a, float b, float c, float d) { _x=a; _y=b; _w=c; _h=d; update(); } Rect w(float a) {_w=a; update(); return this;} Rect h(float a) {_h=a; update(); return this;} float w() {return _w;} float h() {return _h;} void update() { _p = new float[] {_x,_y,_x+_w,_y,_x+_w,_y+_h,_x,_y+_h}; _pc = _p.length/2; mode(CLOSE); super.update(); } } Rect newRect(float a,float b,float c,float d) {return new Rect(a,b,c,d);} class Text extends Location { Font _fnt; String _l; Text(String a, float b, float c) { _l=a; _x=b; _y=c; update(); } Text label(String a) {_l=a; update(); return this;} Text fontFamily(String a) { if (_fnt==null) _fnt = new Font(); _fnt.fontFamily(a);return this; } Text fontSize(int a) { if (_fnt==null) _fnt = new Font(); _fnt.fontSize(a);return this; } Text fontAnchor(int a) { if (_fnt==null) _fnt = new Font(); _fnt.textAnchor(a);return this; } void preDraw() { super.preDraw(); if (_fnt!=null) { System.pushFont(new Font()); _fnt.setProp(); } System.fnt.draw(); } void postDraw() { if (_fnt!=null) System.popFont(); super.postDraw(); } void draw() { preDraw(); text(_l,_x,_y); postDraw(); } } Text newText(String a, float b, float c) {return new Text(a,b,c);} class Ellipse extends Path { float _cx, _cy; float _rx, _ry; Ellipse(float a, float b, float c, float d) { _cx=a; _cy=b; _rx=c; _ry=d; update(); } Ellipse cx(float a) {_cx=a; update(); return this;} Ellipse cy(float a) {_cy=a; update(); return this;} Ellipse rx(float a) {_rx=a; update(); return this;} Ellipse ry(float a) {_ry=a; update(); return this;} float cx() {return _cx;} float cy() {return _cy;} float rx() {return _rx;} float ry() {return _ry;} void update() { float cx = _cx - _rx/2; float cy = _cy - _ry/2; float kappa = 0.5522848; float ox = (_rx / 2) * kappa; float oy = (_ry / 2) * kappa; float xe = cx + _rx; float ye = cy + _ry; float xm = cx + _rx / 2; float ym = cy + _ry / 2; moveTo(cx, ym); cubicTo(cx, ym - oy, xm - ox, cy, xm, cy); cubicTo(xm + ox, cy, xe, ym - oy, xe, ym); cubicTo(xe, ym + oy, xm + ox, ye, xm, ye); cubicTo(xm - ox, ye, cx, ym + oy, cx, ym); super.update(); } } Ellipse newEllipse(float a,float b,float c,float d) {return new Ellipse(a,b,c,d);} class Circle extends Ellipse { float _r; Circle(float a,float b,float c) { super(a,b,c,c); _r=c; update(); } Circle r(float a) {_r=_rx=_ry=a; update(); return this;} float r() {return _r;} } Circle newCircle(float a,float b,float c) {return new Circle(a,b,c);} class Line extends Path { float _x1, _y1, _x2, _y2; Line(float a, float b, float c, float d) { _x1=a;_y1=b;_x2=c;_y2=d;update(); } Line x1(float a) {_x1=a; update(); return this;} Line y1(float a) {_y1=a; update(); return this;} Line x2(float a) {_x2=a; update(); return this;} Line y2(float a) {_y2=a; update(); return this;} float x1() {return _x1;} float y1() {return _y1;} float x2() {return _x2;} float y2() {return _y2;} void update() { _p=new float[]{_x1,_y1,_x2,_y2}; _pc=2; mode(OPEN); super.update(); } } Line newLine(float a,float b,float c,float d) {return new Line(a,b,c,d);} class Polygon extends Path { Polygon(float[] a) {_p=a; _pc=_p.length/2; mode(CLOSE);} Polygon points(float[] a) { _p=a; _pc=_p.length/2; mode(CLOSE); update(); return this; } } Polygon newPolygon(float[] a) {return new Polygon(a);} class Polyline extends Path { Polyline(float[] a) {_p=a; _pc=_p.length/2; mode(OPEN);} Polyline points(float[] a) { _p=a; _pc=_p.length/2; mode(OPEN); update(); return this; } } Polyline newPolyline(float[] a) {return new Polyline(a);} class Symbol { float[] vertices; int mode; Symbol() { vertices = new float[] {-0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,-0.5}; } Symbol(float[] v, int m) { vertices=v; mode=m; } } Symbol newSymbol() { return new Symbol(); } class Mark extends Graphic { float x,y,w,h; Symbol _symbol; Mark(float a, float b, float c, float d) { x=a; y=b; w=c; h=d; } Mark symbol(float[] v) { if (_symbol==null) _symbol = newSymbol(); _symbol.vertices = v; return this; } Mark symbolMode(int m) { if (_symbol==null) _symbol = newSymbol(); _symbol.mode = m; return this; } void pick(int type,float[] params,Action act) {} void draw() { if (System.symbol==null) System.symbol = newSymbol(); Symbol temp=null; preDraw(); if (_symbol!=null) { temp = System.symbol; System.symbol = _symbol; } float[] coords = System.symbol.vertices; beginShape(); for (int i=0;i<coords.length/2;i++) vertex(x+coords[i*2]*System.strokeWidth*w,y+coords[i*2+1]*System.strokeWidth*h); endShape(CLOSE); if (_symbol!=null) System.symbol = temp; postDraw(); } } Mark newMark(float a,float b,float c,float d) { return new Mark(a,b,c,d); }